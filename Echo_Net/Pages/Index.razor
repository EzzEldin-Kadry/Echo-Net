@page "/"

@using Models.Dto;
@using Echo_Net.Services;

@inject IAudioPostService _audioPostService
@inject IJSRuntime mJS


<PageTitle>Index</PageTitle>


<section>
    <audio controls src=@audioRecorderManager.audioBloblURL></audio>
    <hr />
    <button @onclick="RecordAudioStart_Click" class="btn btn-primary" 
        disabled=@audioRecorderManager.mDisableRecordAudioStart>
        Start Record
    </button>
    <button @onclick="RecordAudioPause_Click" class="btn btn-primary" 
        disabled=@audioRecorderManager.mDisableRecordAudioPause>
        Pause
    </button>
    <button @onclick="RecordAudioResume_Click" class="btn btn-primary" 
        disabled=@audioRecorderManager.mDisableRecordAudioResume>
        Resume
    </button>
    <button @onclick="RecordAudioStop_Click" class="btn btn-primary" 
        disabled=@audioRecorderManager.mDisableRecordAudioStop>
        Stop
    </button>
    <button @onclick="RecordAudioSave_Click" class="btn btn-primary" 
        disabled=@audioRecorderManager.mDisableRecordAudioSave>
        Post
    </button>
</section>

@if(audioRecorderManager.audioBloblURL is not null)
{
    <span>
        <p>
            @audioRecorderManager.audioBloblURL
        </p>
    </span>
}


@if(AudioPosts is null || AudioPosts.Count == 0 )
{
    <p>Loading...</p>
}
else
{
    foreach(var item in AudioPosts)
    {
        <div>
            <p>@item.AudioId</p>
            <p>@item.Title</p>
            <p>@item.Description</p>
            <p>@item.AudioUrl</p>
            <p>@item.PostedDate</p>
            <p>@item.OwnerId</p>
        </div>
    }
}


<SurveyPrompt Title="How is Blazor working for you?" />

@code 
{
    string projectPath = new DirectoryInfo(Path.GetDirectoryName(
                            System.Reflection.Assembly.GetExecutingAssembly().Location
                            )).Parent.Parent.Parent.FullName;
    
    AudioRecorderManager audioRecorderManager;
    List<AudioPostDto> AudioPosts { get; set; } = null!;
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if(firstRender)
        {
            //Start Recording Function
            await mJS.InvokeVoidAsync("BlazorAudioRecorder.Initialize", 
                    DotNetObjectReference.Create(this));
            await InitializeAudioRecorderData();
            SetAudioRecorderUIElementsToDefault();
            SetAudioDataDetailsToDefault();

            
            GetAudioPostsFromService();
        }
    }
 
    async void GetAudioPostsFromService()
    {
        var response = await _audioPostService.GetAllAudioPostsAsync<ResponseDto>();
        if(response is not null && response.IsSuccess)
        {
            AudioPosts = Newtonsoft.Json.JsonConvert
                    .DeserializeObject<List<AudioPostDto>>(Convert.ToString(response.Result));
            await InvokeAsync(() => StateHasChanged());
            return;
        }
    }
    public async Task InitializeAudioRecorderData()
    {
        audioRecorderManager.audioBloblURL = string.Empty;
        audioRecorderManager.audioFileName = string.Empty;
        audioRecorderManager.audioExtension = ".wav";
        await InvokeAsync(() => StateHasChanged());
    }
    void SetAudioRecorderUIElementsToDefault()
    {
        audioRecorderManager.mDisableRecordAudioStart = false;
        audioRecorderManager.mDisableRecordAudioPause = true;
        audioRecorderManager.mDisableRecordAudioResume = true;
        audioRecorderManager.mDisableRecordAudioStop = true;
        audioRecorderManager.mDisableRecordAudioSave = true;
    }
    void SetAudioDataDetailsToDefault()
    {
        audioRecorderManager.audioDataBase64 = string.Empty;
    }
    void RecordAudioStart_Click()
    {
        audioRecorderManager.mDisableRecordAudioStart = true;
        audioRecorderManager.mDisableRecordAudioPause = false;
        audioRecorderManager.mDisableRecordAudioResume = true;
        audioRecorderManager.mDisableRecordAudioStop = false;
        audioRecorderManager.mDisableRecordAudioSave = true;

        mJS.InvokeVoidAsync("BlazorAudioRecorder.StartRecord");
    }

    void RecordAudioPause_Click()
    {
        audioRecorderManager.mDisableRecordAudioStart = true;
        audioRecorderManager.mDisableRecordAudioPause = true;
        audioRecorderManager.mDisableRecordAudioResume = false;
        audioRecorderManager.mDisableRecordAudioStop = false;
        audioRecorderManager.mDisableRecordAudioSave = true;

        mJS.InvokeVoidAsync("BlazorAudioRecorder.PauseRecord");
    }

    void RecordAudioResume_Click()
    {
        audioRecorderManager.mDisableRecordAudioStart = true;
        audioRecorderManager.mDisableRecordAudioPause = false;
        audioRecorderManager.mDisableRecordAudioResume = true;
        audioRecorderManager.mDisableRecordAudioStop = false;
        audioRecorderManager.mDisableRecordAudioSave = true;

        mJS.InvokeVoidAsync("BlazorAudioRecorder.ResumeRecord");
    }

    void RecordAudioStop_Click()
    {
        
        BeforeSaveStateRecordAudio();
        mJS.InvokeVoidAsync("BlazorAudioRecorder.StopRecord");
        audioRecorderManager.audioFileName = "MyEcho_"+ (new Random()).Next() + Constants.DateTimeStamp();
    }
    void BeforeSaveStateRecordAudio()
    {
        audioRecorderManager.mDisableRecordAudioStart = false;
        audioRecorderManager.mDisableRecordAudioPause = true;
        audioRecorderManager.mDisableRecordAudioResume = true;
        audioRecorderManager.mDisableRecordAudioStop = true;
        audioRecorderManager.mDisableRecordAudioSave = false;
    }
    async Task RecordAudioSave_Click()
    {
        await mJS.InvokeVoidAsync("BlazorAudioRecorder.SendAudioDataFromBlobUrl");
        SetAudioRecorderUIElementsToDefault();
    }
    [JSInvokable]
    public async Task OnAudioUrlSent(string vUrl)
    {
        audioRecorderManager.audioBloblURL = vUrl;
        await InvokeAsync(() => StateHasChanged());
    }

    [JSInvokable]
    public void OnLoadAudioChunks(string audioChunk)
    {
        audioRecorderManager.audioDataBase64 += audioChunk;
    }
    [JSInvokable]
    public async Task OnAudioDataSent(int expectedLengthOfAudioData)
    {
        if(audioRecorderManager.audioDataBase64.Length != expectedLengthOfAudioData)
        {
            SetAudioDataDetailsToDefault();
            await mJS.InvokeVoidAsync("alert", "Audio post corrupted");
            BeforeSaveStateRecordAudio();
            return;
        }
        try
        {
            byte[] audioData = Convert.FromBase64String(audioRecorderManager.audioDataBase64.Split(",")[1]);
            string filePath = Path.Combine(Constants.EchoesLocation, 
                audioRecorderManager.audioFileName + audioRecorderManager.audioExtension);
            string fullPath = Path.Combine(projectPath, filePath);
            using (MemoryStream memoryStream = new MemoryStream(audioData))
            {
                using (FileStream fileStream = new FileStream(fullPath, FileMode.Create))
                {
                    await memoryStream.CopyToAsync(fileStream);
                    SetAudioDataDetailsToDefault();
                    await InitializeAudioRecorderData();
                    await mJS.InvokeVoidAsync("alert", "Audio record posted");
                }
            }
        }
        catch (Exception ex)
        {
            await mJS.InvokeVoidAsync("alert", $"Error posting audio post: {ex.Message}");
        }
    }
    
    struct AudioRecorderManager
    {

        public string audioBloblURL;
        public string audioFileName;
        public string audioExtension;

        public string audioDataBase64;
        
        public bool mDisableRecordAudioStart;
        public bool mDisableRecordAudioPause;
        public bool mDisableRecordAudioResume;
        public bool mDisableRecordAudioStop;
        public bool mDisableRecordAudioSave;
    }

}